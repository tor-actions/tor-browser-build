diff --git a/mingw-w64-headers/include/windows.graphics.directx.direct3d11.interop.h b/mingw-w64-headers/include/windows.graphics.directx.direct3d11.interop.h
new file mode 100644
index 000000000..d7ff1be23
--- /dev/null
+++ b/mingw-w64-headers/include/windows.graphics.directx.direct3d11.interop.h
@@ -0,0 +1,160 @@
+/*** Autogenerated by WIDL 8.0 from include/windows.graphics.directx.direct3d11.interop.idl - Do not edit ***/
+
+#ifdef _WIN32
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+#include <rpc.h>
+#include <rpcndr.h>
+#endif
+
+#ifndef COM_NO_WINDOWS_H
+#include <windows.h>
+#include <ole2.h>
+#endif
+
+#ifndef __windows_graphics_directx_direct3d11_interop_h__
+#define __windows_graphics_directx_direct3d11_interop_h__
+
+#ifndef __WIDL_INLINE
+#if defined(__cplusplus) || defined(_MSC_VER)
+#define __WIDL_INLINE inline
+#elif defined(__GNUC__)
+#define __WIDL_INLINE __inline__
+#endif
+#endif
+
+/* Forward declarations */
+
+#ifndef ____x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_FWD_DEFINED__
+#define ____x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_FWD_DEFINED__
+typedef interface __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess;
+#ifdef __cplusplus
+#define __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess Windows::Graphics::DirectX::Direct3D11::IDirect3DDxgiInterfaceAccess
+namespace Windows {
+    namespace Graphics {
+        namespace DirectX {
+            namespace Direct3D11 {
+                interface IDirect3DDxgiInterfaceAccess;
+            }
+        }
+    }
+}
+#endif /* __cplusplus */
+#endif
+
+/* Headers for imported files */
+
+#include <windows.graphics.directx.direct3d11.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+ * IDirect3DDxgiInterfaceAccess interface
+ */
+#ifndef ____x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_INTERFACE_DEFINED__
+#define ____x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_INTERFACE_DEFINED__
+
+DEFINE_GUID(IID___x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess, 0xa9b3d012, 0x3df2, 0x4ee3, 0xb8,0xd1, 0x86,0x95,0xf4,0x57,0xd3,0xc1);
+#if defined(__cplusplus) && !defined(CINTERFACE)
+} /* extern "C" */
+namespace Windows {
+    namespace Graphics {
+        namespace DirectX {
+            namespace Direct3D11 {
+                MIDL_INTERFACE("a9b3d012-3df2-4ee3-b8d1-8695f457d3c1")
+                IDirect3DDxgiInterfaceAccess : public IUnknown
+                {
+                    virtual HRESULT STDMETHODCALLTYPE GetInterface(
+                        REFIID iid,
+                        void **object) = 0;
+
+                };
+            }
+        }
+    }
+}
+extern "C" {
+#ifdef __CRT_UUID_DECL
+__CRT_UUID_DECL(__x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess, 0xa9b3d012, 0x3df2, 0x4ee3, 0xb8,0xd1, 0x86,0x95,0xf4,0x57,0xd3,0xc1)
+#endif
+#else
+typedef struct __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccessVtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess *This);
+
+    /*** IDirect3DDxgiInterfaceAccess methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetInterface)(
+        __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess *This,
+        REFIID iid,
+        void **object);
+
+    END_INTERFACE
+} __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccessVtbl;
+
+interface __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess {
+    CONST_VTBL __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccessVtbl* lpVtbl;
+};
+
+#ifdef COBJMACROS
+#ifndef WIDL_C_INLINE_WRAPPERS
+/*** IUnknown methods ***/
+#define __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
+#define __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_AddRef(This) (This)->lpVtbl->AddRef(This)
+#define __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_Release(This) (This)->lpVtbl->Release(This)
+/*** IDirect3DDxgiInterfaceAccess methods ***/
+#define __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_GetInterface(This,iid,object) (This)->lpVtbl->GetInterface(This,iid,object)
+#else
+/*** IUnknown methods ***/
+static __WIDL_INLINE HRESULT __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_QueryInterface(__x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess* This,REFIID riid,void **ppvObject) {
+    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
+}
+static __WIDL_INLINE ULONG __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_AddRef(__x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess* This) {
+    return This->lpVtbl->AddRef(This);
+}
+static __WIDL_INLINE ULONG __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_Release(__x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess* This) {
+    return This->lpVtbl->Release(This);
+}
+/*** IDirect3DDxgiInterfaceAccess methods ***/
+static __WIDL_INLINE HRESULT __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_GetInterface(__x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess* This,REFIID iid,void **object) {
+    return This->lpVtbl->GetInterface(This,iid,object);
+}
+#endif
+#ifdef WIDL_using_Windows_Graphics_DirectX_Direct3D11
+#define IID_IDirect3DDxgiInterfaceAccess IID___x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess
+#define IDirect3DDxgiInterfaceAccessVtbl __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccessVtbl
+#define IDirect3DDxgiInterfaceAccess __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess
+#define IDirect3DDxgiInterfaceAccess_QueryInterface __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_QueryInterface
+#define IDirect3DDxgiInterfaceAccess_AddRef __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_AddRef
+#define IDirect3DDxgiInterfaceAccess_Release __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_Release
+#define IDirect3DDxgiInterfaceAccess_GetInterface __x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_GetInterface
+#endif /* WIDL_using_Windows_Graphics_DirectX_Direct3D11 */
+#endif
+
+#endif
+
+#endif  /* ____x_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDxgiInterfaceAccess_INTERFACE_DEFINED__ */
+
+/* Begin additional prototypes for all interfaces */
+
+
+/* End additional prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __windows_graphics_directx_direct3d11_interop_h__ */
diff --git a/mingw-w64-headers/include/windows.graphics.directx.direct3d11.interop.idl b/mingw-w64-headers/include/windows.graphics.directx.direct3d11.interop.idl
new file mode 100644
index 000000000..51e2845ea
--- /dev/null
+++ b/mingw-w64-headers/include/windows.graphics.directx.direct3d11.interop.idl
@@ -0,0 +1,14 @@
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "windows.graphics.directx.direct3d11.idl";
+
+namespace Windows.Graphics.DirectX.Direct3D11 {
+    [
+        uuid(A9B3D012-3DF2-4EE3-B8D1-8695F457D3C1)
+    ]
+    interface IDirect3DDxgiInterfaceAccess : IUnknown {
+        HRESULT GetInterface([in] REFIID iid, [out, iid_is(iid)] void **object);
+    };
+}
diff --git a/mingw-w64-headers/include/wrl/event.h b/mingw-w64-headers/include/wrl/event.h
new file mode 100644
index 000000000..f3ad2826c
--- /dev/null
+++ b/mingw-w64-headers/include/wrl/event.h
@@ -0,0 +1,52 @@
+#ifndef _WRL_EVENT_H_
+#define _WRL_EVENT_H_
+
+// #include <wrl/def.h>
+#include <wrl/internal.h>
+#include <wrl/client.h>
+#include <wrl/implements.h>
+#include <wrl/wrappers/corewrappers.h>
+#include <eventtoken.h>
+// #include <roerrorapi.h>
+
+#include <pshpack8.h>
+
+namespace Microsoft {
+    namespace WRL {
+        namespace Details {
+            template<typename TDelegateInterface>
+            class DelegateArgTraits {};
+
+            template<typename TDelegateInterface, bool isImplements = __is_base_of(ImplementsBase, TDelegateInterface)>
+            struct DelegateArgTraitsHelper;
+
+            template<typename TDelegateInterface>
+            struct DelegateArgTraitsHelper<TDelegateInterface, false> {
+                typedef TDelegateInterface Interface;
+                typedef DelegateArgTraits<decltype(&TDelegateInterface::Invoke)> Traits;
+            };
+
+            template<typename TDelegateInterface>
+            struct DelegateArgTraitsHelper<TDelegateInterface, true> {};
+        }
+
+        template<typename TDelegateInterface, typename TLambda>
+        ComPtr<typename Details::DelegateArgTraitsHelper<TDelegateInterface>::Interface> Callback(TLambda&& callback) noexcept {
+            return 0;
+        }
+
+        template<typename TDelegateInterface, typename TFunc>
+        ComPtr<typename Details::DelegateArgTraitsHelper<TDelegateInterface>::Interface> Callback(TFunc* callback) noexcept {
+            return 0;
+        };
+
+        template<typename TDelegateInterface, typename TCallbackObject, typename... TArgs>
+        ComPtr<typename Details::DelegateArgTraitsHelper<TDelegateInterface>::Interface> Callback(TCallbackObject *object, HRESULT(TCallbackObject::* method)(TArgs...)) noexcept {
+            return 0;
+        }
+    }
+}
+
+#include <poppack.h>
+
+#endif
diff --git a/mingw-w64-headers/include/wrl/implements.h b/mingw-w64-headers/include/wrl/implements.h
new file mode 100644
index 000000000..b6ef5cdd1
--- /dev/null
+++ b/mingw-w64-headers/include/wrl/implements.h
@@ -0,0 +1,394 @@
+#ifndef _WRL_IMPLEMENTS_H_
+#define _WRL_IMPLEMENTS_H_
+
+#include <weakreference.h>
+
+#include <wrl\client.h>
+
+#include <pshpack8.h>
+
+
+namespace Microsoft {
+    namespace WRL {
+        template<typename T>
+        struct CloakedIid : T {};
+
+        enum RuntimeClassType {
+            WinRt                   = 0x0001,
+            ClassicCom              = 0x0002,
+            WinRtClassicComMix      = WinRt | ClassicCom,
+            InhibitWeakReference    = 0x0004,
+            Delegate                = ClassicCom,
+            InhibitFtmBase          = 0x0008,
+            InhibitRoOriginateError = 0x0010
+        };
+
+        template <unsigned int flags>
+        struct RuntimeClassFlags {
+            static const unsigned int value = flags;
+        };
+
+        namespace Details {
+            struct ImplementsBase {};
+        }
+
+        template<typename Derived, typename MixInType, bool hasImplements>
+        struct MixIn {};
+
+        template <typename FactoryInterface>
+        class ComposableBase {};
+
+        namespace Details {
+            class Nil {};
+
+            template <typename T, typename ...TArgs>
+            ComPtr<T> Make(TArgs&&... args) {
+              return nullptr;
+            }
+
+            class DontUseNewUseMake {
+            private:
+                void* operator new(size_t) throw() {
+                    return nullptr;
+                }
+
+            public:
+                void* operator new(size_t, void* placement) throw() {
+                    return nullptr;
+                }
+            };
+
+            template <unsigned int RuntimeClassTypeT>
+            class RuntimeClassBaseT {
+            protected:
+                template<typename T>
+                static HRESULT AsIID(T* implements, REFIID riid, void **ppvObject) throw() {
+                    return 0;
+                }
+
+                template<typename T>
+                static HRESULT GetImplementedIIDS(T* implements, ULONG *iidCount, IID **iids) throw() {
+                    return 0;
+                }
+
+            public:
+                HRESULT RuntimeClassInitialize() throw() {
+                    return 0;
+                }
+            };
+        }
+
+        template <typename I0, typename I1, typename I2 = Details::Nil, typename I3 = Details::Nil,
+                typename I4 = Details::Nil, typename I5 = Details::Nil, typename I6 = Details::Nil,
+                typename I7 = Details::Nil, typename I8 = Details::Nil, typename I9 = Details::Nil>
+        struct ChainInterfaces : I0
+        {
+        protected:
+            template<unsigned int ClassType>
+            static void Verify() throw() {}
+
+            HRESULT CanCastTo(REFIID riid, void **ppv) throw() {
+                return 0;
+            }
+
+            IUnknown* CastToUnknown() throw() {
+                return nullptr;
+            }
+
+            static const unsigned long IidCount;
+
+            static void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+        };
+
+        template <typename DerivedType, typename BaseType, bool hasImplements, typename I1, typename I2, typename I3,
+                typename I4, typename I5, typename I6,
+                typename I7, typename I8, typename I9>
+        struct ChainInterfaces<MixIn<DerivedType, BaseType, hasImplements>, I1, I2, I3, I4, I5, I6, I7, I8, I9>
+        {
+        protected:
+            template<unsigned int ClassType>
+            static void Verify() throw() {}
+
+            HRESULT CanCastTo(REFIID riid, void **ppv) throw() {
+                return 0;
+            }
+
+            IUnknown* CastToUnknown() throw() {
+                return nullptr;
+            }
+
+            static const unsigned long IidCount;
+
+            static void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+        };
+
+        namespace Details {
+            template <typename RuntimeClassFlagsT, bool doStrictCheck, typename ...TInterfaces>
+            struct __declspec(novtable) ImplementsHelper;
+
+            template <typename RuntimeClassFlagsT, bool doStrictCheck, typename I0, typename ...TInterfaces>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, I0, TInterfaces...> : I0, ImplementsHelper<RuntimeClassFlagsT, true, TInterfaces...> {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                template <bool IsDelegateToClass>
+                HRESULT CanCastToHelper(REFIID riid, void **ppv, bool *pRefDelegated) throw();
+
+                template <>
+                HRESULT inline CanCastToHelper<true>(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                template <>
+                HRESULT inline CanCastToHelper<false>(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                HRESULT CanCastTo(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                template <bool IsDelegateToClass> IUnknown* CastToUnknownHelper() throw();
+
+                template <> inline IUnknown* CastToUnknownHelper<true>() throw() {
+                    return nullptr;
+                }
+
+                template <> inline IUnknown* CastToUnknownHelper<false>() throw() {
+                    return nullptr;
+                }
+
+                IUnknown* CastToUnknown() throw() {
+                    return nullptr;
+                }
+
+                template <bool IsDelegateToClass> long GetIidCountHelper() throw();
+
+                template <> inline long GetIidCountHelper<true>() throw() {
+                    return 0;
+                }
+
+                template <> inline long GetIidCountHelper<false>() throw() {
+                    return 0;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                template <bool IsDelegateToClass> void FillArrayWithIidHelper(unsigned long *index, IID* iids) throw();
+
+                template <> inline void FillArrayWithIidHelper<true>(unsigned long *index, IID* iids) throw() {}
+
+                template <> inline void FillArrayWithIidHelper<false>(unsigned long *index, IID* iids) throw() {}
+
+                void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+            };
+
+            template <typename RuntimeClassFlagsT, bool doStrictCheck, typename ...TInterfaces>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, Details::Nil, TInterfaces...> : ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, TInterfaces...> {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                HRESULT CanCastTo(REFIID riid, void **ppv, bool * pRefDelegated) throw() {
+                    return 0;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+            };
+
+            template <typename RuntimeClassFlagsT, bool doStrictCheck>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck>
+            {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                HRESULT CanCastTo(REFIID, void **, bool*) throw() {
+                    return 0;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                void FillArrayWithIid(unsigned long*, IID*) throw() {}
+            };
+
+            template <typename RuntimeClassFlagsT, bool doStrictCheck, typename I0, typename ...TInterfaces>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, CloakedIid<I0>, TInterfaces...> : ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, I0>, ImplementsHelper<RuntimeClassFlagsT, true, TInterfaces...> {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                HRESULT CanCastTo(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                IUnknown* CastToUnknown() throw() {
+                    return 0;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+            };
+
+            template <typename RuntimeClassFlagsT, bool doStrictCheck, typename C0, typename C1, typename C2, typename C3, typename C4, typename C5, typename C6, typename C7, typename C8, typename C9, typename ...TInterfaces>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, ChainInterfaces<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>, TInterfaces...> : ChainInterfaces<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>, ImplementsHelper<RuntimeClassFlagsT, true, TInterfaces...> {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                HRESULT CanCastTo(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                IUnknown* CastToUnknown() throw() {
+                    return nullptr;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+            };
+
+            template <typename RuntimeClassFlagsT, typename DerivedType, typename BaseType, bool hasImplements, typename ...TInterfaces, bool doStrictCheck>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, MixIn<DerivedType, BaseType, hasImplements>, TInterfaces...> : ImplementsHelper<RuntimeClassFlagsT, true, TInterfaces...> {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                HRESULT CanCastTo(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                IUnknown* CastToUnknown() throw() {
+                    return nullptr;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+            };
+
+            template <typename RuntimeClassFlagsT, typename FactoryInterface, bool doStrictCheck, typename ...TInterfaces>
+            struct __declspec(novtable) ImplementsHelper<RuntimeClassFlagsT, doStrictCheck, ComposableBase<FactoryInterface>, TInterfaces...> : ImplementsHelper<RuntimeClassFlagsT, true, ComposableBase<FactoryInterface>> {
+            protected:
+                template <unsigned int RuntimeClassTypeT> friend class Details::RuntimeClassBaseT;
+
+                typedef ImplementsHelper<RuntimeClassFlagsT, true, ComposableBase<FactoryInterface>> Base;
+
+                HRESULT CanCastTo(REFIID riid, void **ppv, bool *pRefDelegated) throw() {
+                    return 0;
+                }
+
+                IUnknown* CastToUnknown() throw() {
+                    return 0;
+                }
+
+                unsigned long GetIidCount() throw() {
+                    return 0;
+                }
+
+                void FillArrayWithIid(unsigned long *index, IID* iids) throw() {}
+            };
+        }
+
+        namespace Details {
+            template <class RuntimeClassFlagsT, bool implementsWeakReferenceSource, bool implementsInspectable, bool implementsFtmBase, typename ...TInterfaces>
+            class __declspec(novtable) RuntimeClassImpl;
+
+            template<typename I0, bool isIInspectable = true>
+            struct IInspectableInjector;
+
+            template<typename I0>
+            struct IInspectableInjector<I0, true> {
+                typedef Details::Nil InspectableIfNeeded;
+            };
+
+            template<typename I0>
+            struct IInspectableInjector<I0, false> {
+                typedef IInspectable InspectableIfNeeded;
+            };
+
+            template <class RuntimeClassFlagsT, typename I0, typename ...TInterfaces>
+            class __declspec(novtable) RuntimeClassImpl<RuntimeClassFlagsT, false, true, false, I0, TInterfaces...> : public Details::ImplementsHelper<RuntimeClassFlagsT, false, typename IInspectableInjector<I0>::InspectableIfNeeded, I0, TInterfaces...>, public RuntimeClassBaseT<RuntimeClassFlagsT::value>, protected RuntimeClassFlags<InhibitWeakReference>, public DontUseNewUseMake {
+            public:
+                typedef RuntimeClassFlagsT ClassFlags;
+
+                STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject) {
+                    return 0;
+                }
+
+                STDMETHOD_(ULONG, AddRef)() {
+                    return 0;
+                }
+
+                STDMETHOD_(ULONG, Release)() {
+                    return 0;
+                }
+
+                STDMETHOD(GetIids)(ULONG *iidCount, IID **iids) {
+                    return 0;
+                }
+
+            protected:
+                RuntimeClassImpl() throw() {}
+
+                virtual ~RuntimeClassImpl() throw() {}
+
+                unsigned long InternalAddRef() throw() {
+                    return 0;
+                }
+
+                unsigned long InternalRelease() throw() {
+                    return 0;
+                }
+
+                unsigned long GetRefCount() const throw() {
+                    return 0;
+                }
+
+            private:
+                volatile long refcount_;
+            };
+        }
+
+        template <typename ...TInterfaces>
+        class RuntimeClass : public Details::RuntimeClassImpl<RuntimeClassFlags<WinRt>, false, true, false, TInterfaces...> {
+            RuntimeClass(const RuntimeClass&);
+
+            RuntimeClass& operator=(const RuntimeClass&);
+
+        public:
+            RuntimeClass() throw() {}
+
+            typedef RuntimeClass RuntimeClassT;
+        };
+
+        template <unsigned int classFlags, typename ...TInterfaces>
+        class RuntimeClass<RuntimeClassFlags<classFlags>, TInterfaces...> : public Details::RuntimeClassImpl<RuntimeClassFlags<classFlags>, false, true, false, TInterfaces...> {
+            RuntimeClass(const RuntimeClass&);
+
+            RuntimeClass& operator=(const RuntimeClass&);
+
+        public:
+            RuntimeClass() throw() {}
+
+            typedef RuntimeClass RuntimeClassT;
+        };
+
+        using Details::Make;
+    }
+}
+
+#include <poppack.h>
+
+#endif
